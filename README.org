#+title: DaemonicCabal.jl

/Run a script many times, compile it once./

Once installed, =DaemonicCabal.jl= provides =juliaclient=, which serves as a
drop-in replacement for a subset of =julia=, with a few extra tricks.

#+begin_example
~$ juliaclient --help

    juliaclient [switches] -- [programfile] [args...]

Switches (a '*' marks the default value, if applicable):

 -v, --version              Display version information
 -h, --help                 Print this message
 --project[=<dir>|@.]       Set <dir> as the home project/environment
 -e, --eval <expr>          Evaluate <expr>
 -E, --print <expr>         Evaluate <expr> and display the result
 -L, --load <file>          Load <file> immediately on all processors
 -i                         Interactive mode; REPL runs and `isinteractive()` is true
 --banner={yes|no|auto*}    Enable or disable startup banner
 --color={yes|no|auto*}     Enable or disable color text
 --history-file={yes*|no}   Load or save history

Client-specific switches:

 --session[=<label>]        Reuse worker state in Main module. With a label,
                            multiple clients can share the same session.
 --revise[=yes|no*]         Enable or disable Revise.jl integration
 --restart                  Kill workers for the project and exit

Daemon management (systemd):

 systemctl --user {start | stop | restart | status} julia-daemon
#+end_example

Currently the client makes use of unix sockets and [[https://unixism.net/loti/what_is_io_uring.html][=io_uring=]], and so only works
on Linux systems at the moment.

* Usage

+ Install somewhere (potentially in a separate package environment)
+ Run =using DaemonicCabal; DaemonicCabal.install()=
+ Use =juliaclient= as a (mostly) drop-in replacement for =julia=

* Sessions

By default, each =juliaclient= invocation runs in a fresh module. Use =--session=
to persist state in =Main= across invocations:

#+begin_example
~$ juliaclient --session -e 'x = 42'
~$ juliaclient --session -e 'println(x)'  # prints 42
#+end_example

Without a label, session affinity is based on the parent process (shell), so
different terminal windows tend to get separate sessions (this is not
guaranteed).

With a label, multiple clients can explicitly share the same session:

#+begin_example
# Terminal A
~$ juliaclient --session=shared -e 'data = [1,2,3]'

# Terminal B (different shell, same label)
~$ juliaclient --session=shared -e 'push!(data, 4); data'  # [1, 2, 3, 4]
#+end_example

Labeled sessions bypass the normal =MAX_CLIENTS= limit, allowing multiple
clients to attach to the same worker simultaneously.

* Configuration

When the daemon starts, it pays attention to the following environmental variables:

| Variable                       | Default                                    | Description                                                     |
|--------------------------------+--------------------------------------------+-----------------------------------------------------------------|
| =JULIA_DAEMON_SERVER=            | =/run/user/$UID/julia-daemon/conductor.sock= | Socket path for client connections                              |
| =JULIA_DAEMON_RUNTIME=           | =/run/user/$UID/julia-daemon=                | Runtime directory for sockets and PID file                      |
| =JULIA_DAEMON_WORKER_EXECUTABLE= | =julia=                                      | Julia binary for workers                                        |
| =JULIA_DAEMON_WORKER_ARGS=       | =--startup-file=no=                          | Arguments passed to worker processes (split on whitespace)      |
| =JULIA_DAEMON_WORKER_PROJECT=    | (none)                                     | Project for the worker itself (not client projects)             |
| =JULIA_DAEMON_WORKER_MAXCLIENTS= | =1=                                          | Max clients per worker (0 = unlimited)                          |
| =JULIA_DAEMON_WORKER_TTL=        | =7200=                                       | Worker idle timeout in seconds (2 hours)                        |
| =JULIA_DAEMON_LABEL_TTL=         | =90=                                         | Session label retention after last client disconnects (seconds) |
| =JULIA_DAEMON_REVISE=            | =no=                                         | Enable Revise.jl by default (also settable with =--revise=)       |

The client also reads =JULIA_DAEMON_SERVER= and =JULIA_DAEMON_RUNTIME= to locate
the conductor socket.

* Architecture

#+begin_example
┌─────────────────┐      ┌──────────────────┐      ┌──────────────────────┐
│  Client (Zig)   │─────▶│  Conductor (Zig) │─────▶│  Worker Pool (Julia) │
└────────┬────────┘      └──────────────────┘      └────────┬─────────────┘
         │                                                  │
         └────────────────── stdio ─────────────────────────┘
#+end_example

- *Client*: Lightweight Zig binary users invoke. Connects to conductor to get
  assigned a worker, then connects directly to the worker for stdio/signals
  via =io_uring=.
- *Conductor*: Zig daemon managing the worker pool. Spawns workers per-project,
  routes client requests, maintains environment fingerprint cache.
- *Worker*: Julia process handling client sessions. Each worker serves one project
  and can handle multiple clients.

* Caveats

+ A worker is started per-project, so running scripts in different projects
  incurs separate startup/compile costs.
+ The REPL works but wasn't designed for multiple concurrent REPLs per process.
+ Linux-only, due to the dependency on =io_uring=
